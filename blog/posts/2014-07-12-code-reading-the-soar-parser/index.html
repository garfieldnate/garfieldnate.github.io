<!DOCTYPE html>
<html lang="en" class="astro-6MTULHJX">
    <head>
        <!-- Global Metadata --><meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<link rel="icon" type="image/x-icon" href="/favicon.ico">

<!-- Primary Meta Tags -->
<title>Code Reading: The Soar Parser</title>
<meta name="title" content="Code Reading: The Soar Parser">
<meta name="description" content="Digging in to a large C++ project">

<!-- Open Graph / Facebook -->
<meta property="og:type" content="website">
<meta property="og:url" content="https://www.nateglenn.com/blog/posts/2014-07-12-code-reading-the-soar-parser/">
<meta property="og:title" content="Code Reading: The Soar Parser">
<meta property="og:description" content="Digging in to a large C++ project">
<meta property="og:image" content="/assets/portfolio/ja_segmenting.jpg">

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image">
<meta property="twitter:url" content="https://www.nateglenn.com/blog/posts/2014-07-12-code-reading-the-soar-parser/">
<meta property="twitter:title" content="Code Reading: The Soar Parser">
<meta property="twitter:description" content="Digging in to a large C++ project">
<meta property="twitter:image" content="/assets/portfolio/ja_segmenting.jpg">

<!-- Fonts -->
<!-- Load google fonts in as performant a way as possible -->
<!-- (see https://web.dev/defer-non-critical-css/) -->

<!-- preconnect to location of google fonts' .woff files -->
<link rel="preconnect" href="https://fonts.gstatic.com">

<!-- request stylesheet asynchronously, update the element to a normal stylesheet when the resources are loaded -->
<link rel="preload" href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&family=IBM+Plex+Sans:wght@400;700&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'">

<!-- fallback for browsers that don't execute JS -->
<noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&family=IBM+Plex+Sans:wght@400;700&display=swap"></noscript>

    <link rel="stylesheet" href="/assets/fd12c972.9c857589.css" />
<link rel="stylesheet" href="/assets/df0ad7d9.0f788cdb.css" /><script type="module">const{classList:e}=document.documentElement,A=e.add.bind(e);A("jpeg");A("png");const g=(B,d)=>{const a=new Image;a.src=`data:image/${B};base64,${d}`,a.onload=A(B)};g("webp","UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==");g("avif","AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=");
</script></head>

    <body class="astro-6MTULHJX">
        <header class="wrapper astro-5EYVJML5">
    <nav class="astro-5EYVJML5">
        <a href="/" class="astro-5EYVJML5">
            <span class="astro-5EYVJML5">Home</span>
        </a>
        <a href="/#portfolio" class="astro-5EYVJML5">
            <span class="astro-5EYVJML5">Portfolio</span>
        </a>
        <a href="/resume/resume-en.html" class="astro-5EYVJML5">
            <span class="astro-5EYVJML5">Resume</span>
        </a>
        <a href="/blog" class="astro-5EYVJML5">
            <span class="astro-5EYVJML5">Blog</span>
        </a>
        <a href="https://www.linkedin.com/in/nathanglenn" class="astro-5EYVJML5">
            <span class="astro-5EYVJML5">LinkedIn</span>
        </a>
        <a href="https://github.com/garfieldnate/" class="astro-5EYVJML5">
            <span class="astro-5EYVJML5">GitHub</span>
        </a>
    </nav>
</header>


        <article class="wrapper content astro-6MTULHJX">
            <header class="astro-6MTULHJX">
                
                <h1 class="title astro-6MTULHJX">Code Reading: The Soar Parser</h1>
                <!-- Machine readable datetime attribute, human-readable text --><time datetime="2014-07-12">12 Jul 2014</time>
            </header>
            <main class="astro-6MTULHJX">
                <p>I’ve thought for a while that it would be fun to write a series of “code reading” posts, where I try to read and understand how some large program works and explain my findings.</p><p>To investigate the possibility of an upcoming project, I’ve been wanting to know how Soar parses productions, and if there’s any way to retrofit it to make a parser usable by various IDE’s. I have tried to make <a href="https://github.com/garfieldnate/Soar-Production">two</a> <a href="https://github.com/garfieldnate/Java-Soar-Parser">separate</a> parsers for Soar code already, and it just seems to be difficult to imitate the real thing. If you’d like to follow along, you can view or download the code on <a href="https://github.com/SoarGroup/Soar/tree/34b1881a57777083cd72d0dcb3d1e56a7bb59701">GitHub</a>:</p><p>Disclaimer: My “critiques” of the code are areas that I think can use some contributions or TLC. Soar was written and is maintained by programmers and researchers far greater than I, and I am not dismissing the hard work and craft that went into its construction. The Soar code has evolved over 20-30 years in an academic environment, and I expect it to have a few rough edges.</p><h2 id="step-0-some-background-knowledge">Step 0: Some Background Knowledge</h2><p>OK, so I guess background knowledge would be useful for the readers. <a href="http://sitemaker.umich.edu/soar/home">Soar</a> is a  cognitive architecture used for creating agents. Cognitive meaning it provides the basic faculties required for gaining and using knowledge, and agents meaning programs that make choices to accomplish a goal of some kind. Soar has its own programming language, and instead of the familiar loops and functions it has productions. Soar code looks something like this:</p><pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">watch </span><span style="color: #79C0FF">5</span></span>
<span class="line"><span style="color: #FF7B72">source</span><span style="color: #C9D1D9"> somefile.txt</span></span>
<span class="line"><span style="color: #C9D1D9">sp {some*production</span></span>
<span class="line"><span style="color: #C9D1D9">    (state &lt;s&gt; ^foo |want greeting|)</span></span>
<span class="line"><span style="color: #C9D1D9">--&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">    (&lt;s&gt; ^operator &lt;o&gt;)</span></span>
<span class="line"><span style="color: #C9D1D9">    (&lt;o&gt; ^name hello-world ^greeting |hello world|)</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre><p>The first two lines are commands; the first makes the command line interface much more verbose and the second loads another Soar file. The <code>sp {...}</code> is a Soar production, which is where the bulk of the language features are. Productions do all the work (thus soar is called a <a href="https://en.wikipedia.org/wiki/Production_system">production system</a>). Productions match the program state (<a href="https://en.wikipedia.org/wiki/Working_memory">working memory</a>) and make changes to it if the match is successful. The production above matches a state that has a <code>foo</code> attribute with a value of <code>want greeting</code>, and if that succeeds then it creates a special <code>operator</code> attribute which in turn has two more attributes. Working memory is organized like a network of attributes and values, and Soar cycles over the productions, changing memory and working towards a goal. This is accomplished efficiently through the <a href="https://en.wikipedia.org/wiki/Rete_algorithm">RETE</a> algorithm, which I’d like to study another time.</p><p>That all might leave it unclear, but at least understand that Soar is cool because it allows you to make programs that <a href="http://sitemaker.umich.edu/soar/files/mohan.pdf">play Mario</a>, <a href="http://www.isi.edu/soar/soar-ifor-project.html">fly planes</a>, or <a href="http://www.cs.cmu.edu/afs/cs/project/soar/utc/nl/doc/nl-homepage.html">talk</a> (all of those with caveats, of course; work is ongoing).</p><h2 id="step-1-try-to-build-it">Step 1: Try to Build It</h2><p>The first thing I wanted was to build Soar on my own computer. After all, if I can’t even build it, what’s the point in trying to modify it? I’ve always had terrible experiences trying to build C/C++ projects on Windows. This was a little better because Windows is supported and a release is provided regularly, but there were still hiccups.</p><p>The build instructions are <a href="">here</a>. To do a full build you need Python, SWIG, Tcl, and a C++ compiler toolchain. The build is done via <a href="http://www.scons.org/">Scons</a>, but batch and sh files are used to do initial checking of the available tools (and it’s easier to double-click a batch file on Windows than to call Python). My first attempt ended in an uncaught error dumping messages to the screen because I had not used the Visual Studio Prompt. Once I figured this out (and <a href="https://github.com/SoarGroup/Soar/pull/161">improved</a> the message for future users) the build died again trying to generate C# bindings. This was reported and <a href="https://github.com/SoarGroup/Soar/issues/160">fixed</a>, after which I was able to do a partial build. I had some more <a href="https://github.com/SoarGroup/Soar/issues/165">trouble</a> because I was using the wrong MSVC toolchain(!), but now it builds without any issues.</p><p>Overall, the build system is very nice. It’s hands-off, and just works. The maintainers are very responsive and dedicated to a working cross-platform build. I do wish there were more comments in the build scripts, since I have never used Scons and had some trouble looking through it. Also it would be nice to have the build instructions in the repository instead of on a separate website.</p><h2 id="step-2-how-does-soar-parse-soar-code">Step 2: How does Soar parse Soar code?</h2><p>The answer to this turned out to be more interesting than I thought. My own attempts at writing a single Soar parser didn’t work very well because Soar actually has two parsers! Well, actually it has 76 parsers; one to split commands into constituents and then one for each of 75 possible Soar commands. <code>sp</code> is just one of many commands.</p><p>Let’s start by looking at what happens when you source a file. The code for the source command is in <a href="https://github.com/SoarGroup/Soar/blob/34b1881a57777083cd72d0dcb3d1e56a7bb59701/Core/CLI/src/cli_source.cpp"><code>Core/CLI/src/cli_source.cpp</code></a>. <code>DoSource</code> of line 80 is called, and after loading the input file into memory and doing some error checking and logging it calls <code>Source</code> of line 212. Only the first 4 lines matter for understanding the parser:</p><pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// line 212</span></span>
<span class="line"><span style="color: #FF7B72">bool</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">CommandLineInterface</span><span style="color: #C9D1D9">::</span><span style="color: #D2A8FF">Source</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">char*</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">buffer</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">bool</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">printFileStack</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FFA657">soar</span><span style="color: #C9D1D9">::tokenizer tokenizer;</span></span>
<span class="line"><span style="color: #C9D1D9">    tokenizer.</span><span style="color: #D2A8FF">set_handler</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&amp;</span><span style="color: #C9D1D9">m_Parser);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (tokenizer.</span><span style="color: #D2A8FF">evaluate</span><span style="color: #C9D1D9">(buffer))</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">;</span></span></code></pre><p>It creates a new <code>tokenizer</code> and sets its handler to <code>m_parser</code>, the main CLI parser available from <code>cli_commandLineInterface.h</code>. The parser can be passed to <code>set_handler</code> because it implements <code>tokenizer_callback</code> (declared in <a href="https://github.com/SoarGroup/Soar/blob/34b1881a57777083cd72d0dcb3d1e56a7bb59701/Core/shared/tokenizer.h"><code>tokenizer.h</code></a>) by having the <code>handle_command</code> method:</p><pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// line 43</span></span>
<span class="line"><span style="color: #8B949E">/**</span></span>
<span class="line"><span style="color: #8B949E"> * Implement to handle commands. The words of the command are in the</span></span>
<span class="line"><span style="color: #8B949E"> * passed argv vector. The first entry in the vector is the command.</span></span>
<span class="line"><span style="color: #8B949E"> * The vector is guaranteed to never be empty, though the first command</span></span>
<span class="line"><span style="color: #8B949E"> * could be.</span></span>
<span class="line"><span style="color: #8B949E"> * </span><span style="color: #FF7B72">@return</span><span style="color: #8B949E"> true if the command was ok, or false if there is an error.</span></span>
<span class="line"><span style="color: #8B949E"> *         Returning false will stop parsing and cause</span></span>
<span class="line"><span style="color: #8B949E"> *         tokenizer::evaluate to return false.</span></span>
<span class="line"><span style="color: #8B949E"> */</span></span>
<span class="line"><span style="color: #FF7B72">virtual</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">bool</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">handle_command</span><span style="color: #C9D1D9">(</span><span style="color: #FFA657">std</span><span style="color: #C9D1D9">::</span><span style="color: #FFA657">vector</span><span style="color: #C9D1D9">&lt;</span><span style="color: #FFA657">std</span><span style="color: #C9D1D9">::</span><span style="color: #FFA657">string</span><span style="color: #C9D1D9">&gt;</span><span style="color: #FF7B72">&amp;</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">argv</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span></code></pre><p>Next, <a href="https://github.com/SoarGroup/Soar/blob/34b1881a57777083cd72d0dcb3d1e56a7bb59701/Core/shared/tokenizer.h"><code>tokenizer.h</code></a> tells me why I got it wrong when I tried to make my own Soar parser:</p><pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// line 186</span></span>
<span class="line"><span style="color: #8B949E"> /**</span></span>
<span class="line"><span style="color: #8B949E">     * Essentially implements a simple Tcl parser, with some exceptions.</span></span>
<span class="line"><span style="color: #8B949E">     *</span></span>
<span class="line"><span style="color: #8B949E">     * Takes a string and farily efficiently converts it in to a series of</span></span>
<span class="line"><span style="color: #8B949E">     * callbacks with arguments separated in to a vector of strings (what Tcl</span></span>
<span class="line"><span style="color: #8B949E">     * refers to as &quot;words&quot;).</span></span>
<span class="line"><span style="color: #8B949E">     *</span></span></code></pre><p>So I’ve had it backwards, building a Soar production parser and then as an afterthought adding methods to parse other commands. This “tokenizer” parses Tcl commands and enforces rules on the individual words. For instance, this checks that curly braces match within words, and follows rules of escaping and quoting inside of and outside of quoted and curly-braced sections. This would certainly make some parts of a production parser simpler!</p><p>So <code>tokenizer::evaluate</code> parses individual Tcl commands and sends them to the <code>handle_command</code> routine of <code>/Core/CLI/src/cli_Parser.h</code>. This then finds a <code>ParserCommand</code> object using a prefix lookup on the first word of the command; i.e. <code>wa</code> gives you the <code>watch</code> command, <code>pr</code> gives you the <code>print</code> command, etc. The prefix search is basically this:</p><ul>
<li>given a command string <code>$str</code>:
<ul>
<li>make a list of all commands that start with the same letter as $str
<ul>
<li>for each next letter in $str
<ul>
<li>remove the commands that don’t have the same letter at the same spot</li>
</ul>
</li>
<li>return the list of matching commands</li>
</ul>
</li>
</ul>
</li>
</ul><p>If more than one matching command is found, then the input is ambiguous and a warning is printed and no command is executed. Hmm, there’s a TODO note there about using a simpler lookup mechanism.</p><p>How is the list of commands populated in the first place? Using the parser’s <code>AddCommand</code> method. All of the normal Soar commands are added at runtime in <a href="https://github.com/SoarGroup/Soar/blob/34b1881a57777083cd72d0dcb3d1e56a7bb59701/Core/CLI/src/cli_CommandLineInterface.cpp"><code>cli_CommandLineInterface.cpp</code></a>, and there are some other examples of <code>AddCommand</code> in the test code.</p><pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// line 40</span></span>
<span class="line"><span style="color: #C9D1D9">m_Parser.</span><span style="color: #D2A8FF">AddCommand</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">new</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">cli</span><span style="color: #C9D1D9">::</span><span style="color: #D2A8FF">AddWMECommand</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">*</span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">));</span></span>
<span class="line"><span style="color: #C9D1D9">m_Parser.</span><span style="color: #D2A8FF">AddCommand</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">new</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">cli</span><span style="color: #C9D1D9">::</span><span style="color: #D2A8FF">AliasCommand</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">*</span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">));</span></span>
<span class="line"><span style="color: #C9D1D9">m_Parser.</span><span style="color: #D2A8FF">AddCommand</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">new</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">cli</span><span style="color: #C9D1D9">::</span><span style="color: #D2A8FF">AllocateCommand</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">*</span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">));</span></span>
<span class="line"><span style="color: #C9D1D9">m_Parser.</span><span style="color: #D2A8FF">AddCommand</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">new</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">cli</span><span style="color: #C9D1D9">::</span><span style="color: #D2A8FF">BreakCommand</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">*</span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">));</span></span>
<span class="line"><span style="color: #C9D1D9">m_Parser.</span><span style="color: #D2A8FF">AddCommand</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">new</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">cli</span><span style="color: #C9D1D9">::</span><span style="color: #D2A8FF">CaptureInputCommand</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">*</span><span style="color: #79C0FF">this</span><span style="color: #C9D1D9">));</span></span>
<span class="line"><span style="color: #C9D1D9">...</span></span></code></pre><p>The commands themselves are <code>ParserCommand</code> objects and are all declared in <a href="https://github.com/SoarGroup/Soar/blob/34b1881a57777083cd72d0dcb3d1e56a7bb59701/Core/CLI/src/cli_Commands.h"><code>cli_Commands.h</code></a>. The structure of a command class is given in <code>cli_parser.h</code>:</p><pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// line 15</span></span>
<span class="line"><span style="color: #FF7B72">class</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">ParserCommand</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #FF7B72">public:</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">virtual</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">~ParserCommand</span><span style="color: #C9D1D9">() {};</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">virtual</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">char*</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">GetString</span><span style="color: #C9D1D9">() </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">virtual</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">char*</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">GetSyntax</span><span style="color: #C9D1D9">() </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">virtual</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">bool</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">Parse</span><span style="color: #C9D1D9">(</span><span style="color: #FFA657">std</span><span style="color: #C9D1D9">::</span><span style="color: #FFA657">vector</span><span style="color: #C9D1D9">&lt;</span><span style="color: #FFA657">std</span><span style="color: #C9D1D9">::</span><span style="color: #FFA657">string</span><span style="color: #C9D1D9">&gt;</span><span style="color: #FF7B72">&amp;</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">argv</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">};</span></span></code></pre><p><code>GetString</code> is the name of the command and is used as the first word in the command invocation (<code>watch</code>, <code>sp</code>, etc.). This is used by the prefix lookup code discussed above. <code>GetSyntax</code> gives a usage statement in case the user invokes the command incorrectly. <code>Parse</code> is the meat of the command; it takes the list of command words and performs the action specified by them.</p><p>Although the <code>Parse</code> method could directly contain the command actions, all of the <code>Parse</code> implementations simply parse the command and then call <code>DoXYZ</code>. These methods are declared in <code>cli_Cli.h</code> and are implemented in their own files (<code>cli_source.cpp</code>, <code>cli_break.cpp</code>, etc.). Here is the implemention of the <code>sp</code> command as an example:</p><pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// line 3393</span></span>
<span class="line"><span style="color: #FF7B72">class</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">SPCommand</span><span style="color: #C9D1D9"> : </span><span style="color: #FF7B72">public</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">cli</span><span style="color: #C9D1D9">::</span><span style="color: #FFA657">ParserCommand</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #FF7B72">public:</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">SPCommand</span><span style="color: #C9D1D9">(</span><span style="color: #FFA657">cli</span><span style="color: #C9D1D9">::</span><span style="color: #FFA657">Cli</span><span style="color: #FF7B72">&amp;</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">cli</span><span style="color: #C9D1D9">) : </span><span style="color: #D2A8FF">cli</span><span style="color: #C9D1D9">(cli), </span><span style="color: #D2A8FF">ParserCommand</span><span style="color: #C9D1D9">() {}</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">virtual</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">~SPCommand</span><span style="color: #C9D1D9">() {}</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">virtual</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">char*</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">GetString</span><span style="color: #C9D1D9">() </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> { </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&quot;sp&quot;</span><span style="color: #C9D1D9">; }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">virtual</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">char*</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">GetSyntax</span><span style="color: #C9D1D9">() </span><span style="color: #FF7B72">const</span></span>
<span class="line"><span style="color: #C9D1D9">    {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">return</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #A5D6FF">&quot;Syntax: sp {production_body}&quot;</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">virtual</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">bool</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">Parse</span><span style="color: #C9D1D9">(</span><span style="color: #FFA657">std</span><span style="color: #C9D1D9">::</span><span style="color: #FFA657">vector</span><span style="color: #C9D1D9">&lt; </span><span style="color: #FFA657">std</span><span style="color: #C9D1D9">::</span><span style="color: #FFA657">string</span><span style="color: #C9D1D9"> &gt;</span><span style="color: #FF7B72">&amp;</span><span style="color: #FFA657">argv</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">    {</span></span>
<span class="line"><span style="color: #8B949E">        // One argument (the stuff in the brackets, minus the brackets</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (argv.</span><span style="color: #D2A8FF">size</span><span style="color: #C9D1D9">() </span><span style="color: #FF7B72">&lt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> cli.</span><span style="color: #D2A8FF">SetError</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">GetSyntax</span><span style="color: #C9D1D9">());</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (argv.</span><span style="color: #D2A8FF">size</span><span style="color: #C9D1D9">() </span><span style="color: #FF7B72">&gt;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> cli.</span><span style="color: #D2A8FF">SetError</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">GetSyntax</span><span style="color: #C9D1D9">());</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> cli.</span><span style="color: #D2A8FF">DoSP</span><span style="color: #C9D1D9">(argv[</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">]);</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">private:</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FFA657">cli</span><span style="color: #C9D1D9">::Cli</span><span style="color: #FF7B72">&amp;</span><span style="color: #C9D1D9"> cli;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FFA657">SPCommand</span><span style="color: #FF7B72">&amp;</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">operator</span><span style="color: #FFA657">=</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">SPCommand</span><span style="color: #FF7B72">&amp;</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">};</span></span></code></pre><p>The <code>DoSP</code> command is in <a href="https://github.com/SoarGroup/Soar/blob/34b1881a57777083cd72d0dcb3d1e56a7bb59701/Core/CLI/src/cli_sp.cpp"><code>cli_sp.cpp</code></a>. Here, some craziness comes out. We find <code>soarAlternateInput</code>, which has no documentation and relates to fuctionality that is rather unclear. Then we have the use of a global agent provided by the global <code>m_pAgentSML</code> of <code>cli_CommandLineInterface.h</code>.</p><pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// line 42</span></span>
<span class="line"><span style="color: #C9D1D9">agent</span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> agnt </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> m_pAgentSML-&gt;</span><span style="color: #D2A8FF">GetSoarAgent</span><span style="color: #C9D1D9">();</span></span>
<span class="line"><span style="color: #D2A8FF">soarAlternateInput</span><span style="color: #C9D1D9">( agnt, productionString.</span><span style="color: #D2A8FF">c_str</span><span style="color: #C9D1D9">(), </span><span style="color: #FF7B72">const_cast&lt;char*&gt;</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">&quot;) &quot;</span><span style="color: #C9D1D9">), </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9"> );</span></span>
<span class="line"><span style="color: #D2A8FF">set_lexer_allow_ids</span><span style="color: #C9D1D9">( agnt, </span><span style="color: #79C0FF">false</span><span style="color: #C9D1D9"> );</span></span>
<span class="line"><span style="color: #D2A8FF">get_lexeme</span><span style="color: #C9D1D9">( agnt );</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">production</span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> p;</span></span>
<span class="line"><span style="color: #FF7B72">unsigned</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> rete_addition_result </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">p </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">parse_production</span><span style="color: #C9D1D9">( agnt, </span><span style="color: #FF7B72">&amp;</span><span style="color: #C9D1D9">rete_addition_result );</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D2A8FF">set_lexer_allow_ids</span><span style="color: #C9D1D9">( agnt, </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9"> );</span></span>
<span class="line"><span style="color: #D2A8FF">soarAlternateInput</span><span style="color: #C9D1D9">( agnt, </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9"> );</span></span></code></pre><p>The lexer and parser files in <code>\Core\SoarKernel\src</code> work together to load a production, with the parser repeatedly calling <code>get_lexeme</code> (line 747 of <a href="https://github.com/SoarGroup/Soar/blob/34b1881a57777083cd72d0dcb3d1e56a7bb59701/Core/SoarKernel/src/lexer.cpp"><code>lexer.cpp</code></a>) to find the next token. After checking for comments and doing some other stuff I don’t get yet (<code>fake_rparen_at_eol</code>) it calls a lexing method based on the current character in the buffer using <code>lexer_routines</code> as a dispatch table.</p><pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// line 840</span></span>
<span class="line"><span style="color: #D2A8FF">record_position_of_start_of_lexeme</span><span style="color: #C9D1D9">(thisAgent);</span></span>
<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (thisAgent-&gt;current_char</span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9">EOF)</span></span>
<span class="line"><span style="color: #C9D1D9">  (</span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">(lexer_routines[</span><span style="color: #FF7B72">static_cast&lt;unsigned</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">char&gt;</span><span style="color: #C9D1D9">(thisAgent-&gt;current_char)]))(thisAgent);</span></span>
<span class="line"><span style="color: #FF7B72">else</span></span>
<span class="line"><span style="color: #C9D1D9">  </span><span style="color: #D2A8FF">lex_eof</span><span style="color: #C9D1D9">(thisAgent);</span></span></code></pre><p>The explicit functionality of the tokenizer and parser are nicely separated, meaning that production tokenizing can be done context-free, or without the parser sharing knowledge with the tokenizer. However, things are actually crazier than that because the lexer is tied intimately with an <a href="https://github.com/SoarGroup/Soar/blob/34b1881a57777083cd72d0dcb3d1e56a7bb59701/Core/SoarKernel/src/agent.h">agent</a>:</p><pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// line 256</span></span>
<span class="line"><span style="color: #8B949E">/* ----------------------- Lexer stuff -------------------------- */</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">lexer_source_file </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> current_file;</span><span style="color: #8B949E"> /* file we&#39;re currently reading */</span></span>
<span class="line"><span style="color: #FF7B72">int</span><span style="color: #C9D1D9">                 current_char;</span><span style="color: #8B949E"> /* holds current input character */</span></span>
<span class="line"><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">lexeme_info</span><span style="color: #C9D1D9">  lexeme;</span><span style="color: #8B949E">       /* holds current lexeme */</span></span>
<span class="line"><span style="color: #C9D1D9">Bool                print_prompt_flag;</span></span></code></pre><p>The <code>get_lexeme</code> method requires an agent as an argument, even though the agent was provided via <code>init_lexer</code>. During tokenization, <code>get_lexeme</code> sets the <code>lexeme</code> and <code>current_char</code> fields in the agent. So even though there’s a nice separation of parser and lexer/tokenizer, there is potential there for the parser to change the state of the lexer, the input buffer, etc. It doesn’t look like that happens, but it’s not a good possibility. You also have to call <code>get_lexeme</code> before calling <code>parse_production</code>, and <code>parse_production</code> adds the input production to the RETE network directly instead of returning a parsed production. There’s severe coupling between the lexer, the agent, and the parser. This could probably be remedied easily. Ideally the lexer would need only text and return a stream of tokens with no side effects; the parser would instantiate the lexer and would have access to an agent for the RHS functions.</p><h2 id="step-4-how-does-gp-work">Step 4: How does <code>gp</code> work?</h2><p><code>gp</code> is a command that generates new Soar productions by permuting values inside of square brackets in an otherwise normal-looking production. <code>gp</code> was an added mystery to me because its syntax was almost the same as that for <code>sp</code>, but it allowed syntactic variations deep in the parse tree. Here is an example <code>gp</code> statement:</p><pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">gp {gp*test1</span></span>
<span class="line"><span style="color: #C9D1D9">(state &lt;s&gt; ^operator &lt;o&gt; +</span></span>
<span class="line"><span style="color: #C9D1D9">           ^someflag [true false])   # some normal values</span></span>
<span class="line"><span style="color: #C9D1D9">(&lt;o&gt; ^name foo</span></span>
<span class="line"><span style="color: #C9D1D9">     ^att [val1 </span><span style="color: #79C0FF">1.3</span><span style="color: #C9D1D9"> |another val|])  # a value with a space, in pipes</span></span>
<span class="line"><span style="color: #C9D1D9">--&gt;</span></span>
<span class="line"><span style="color: #C9D1D9">(&lt;s&gt; ^operator &lt;o&gt; </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">5</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre><p>This turned out to be simple once I understood CLI parsing. <code>DoGP</code> is located in <a href="https://github.com/SoarGroup/Soar/blob/34b1881a57777083cd72d0dcb3d1e56a7bb59701/Core/CLI/src/cli_gp.cpp"><code>/Core/CLI/src/cli_gp.cpp</code></a>. It simply looks for the special <code>[]</code> syntax in a string and generates new strings to be loaded as productions by <code>DoSP</code>. This is simple and easy, but means that there may not be an easy way to do syntax coloring for it.</p><pre class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #8B949E">// line 276</span></span>
<span class="line"><span style="color: #FF7B72">if</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">!</span><span style="color: #D2A8FF">DoSP</span><span style="color: #C9D1D9">(generatedProduction))</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">false</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre><h2 id="conclusions">Conclusions</h2><p>Reading the Soar parser code is an awesome exercise that I plan to continue. I probably won’t write up another post as detailed as this one, instead writing a code guide once I’ve grokked it well enough. That will probably be a better contribution to the writers, anyway.</p><p>Reading it was actually an interesting bit of archaeology, too. There are notes sprinkled about with author initials and dates back to at least 1994. Notes like that would not have been necessary if a version control system had been available or in use. There are also bug numbers referring to a long-gone database, references to code that doesn’t exist anymore, and commented commented comments. I wish that project history were available prior to 2010.</p><p>The design of the Soar parser makes a lot of sense to me now. A Tcl parser parses commands, verifying quotes, escaping, comments and brace or quote matching; a command object is located and is given the command arguments; the command object then parses the arguments and takes whatever action is required. It should be a simple process to create and register new commands in Soar.</p><p>The parser and tokenizer for Soar productions are not difficult to understand as far as their operation goes. However, the strong coupling and use of global variables need improvement, especially if <a href="http://sourceforge.net/p/soar/mailman/message/22147559/">parallelization is a concern</a>.</p><h3 id="low-hanging-fruits">Low-Hanging Fruits</h3><ul>
<li>Rename the parsers and tokenizers so they don’t get confused:
<ul>
<li><code>Core/SoarKernel/src/lexer</code> -> <code>Core/SoarKernel/src/production_tokenizer</code></li>
<li><code>Core/SoarKernel/src/parser</code> - <code>Core/SoarKernel/src/production_parser</code></li>
<li><code>Core/shared/tokenizer</code> -> <code>Core/CLI/src/cli_tokenizer</code></li>
<li><code>Core/CLI/src/cli_parser</code> -> this one is fine</li>
</ul>
</li>
<li>add a project README containing build instructions</li>
<li>consistency
<ul>
<li>choose tabs or spaces, but not both!</li>
<li>put declarations at either top or bottom of file</li>
<li>capitalize or don’t capitalize names; camelCase or snake_case</li>
</ul>
</li>
<li>find and remove commented-out code</li>
<li>read and grok the code, then add comments about what it does</li>
</ul><p>A less low-hanging fruit would be trying to address some of the many <code>TODO</code>/<code>BUGBUG</code>/<code>FIXME</code>/<code>need</code> notes sprinkled throughout. Interestingly, searching <code>FIXME</code> gives lots of results in the included Scons distribution, as well!</p>
            </main>
        </article>
        <footer class="astro-UAFV37XX"><a href="/blog/rss.xml" class="astro-UAFV37XX"><img src="/rss/rss-icon.svg" height="15px" width="15px" alt="RSS logo" class="astro-UAFV37XX"> RSS</a>・<a href="/license" class="astro-UAFV37XX">License</a>・<a href="https://github.com/garfieldnate/garfieldnate.github.io" class="astro-UAFV37XX">Source</a></footer>


    
</body></html>